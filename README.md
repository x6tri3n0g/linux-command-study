# Linux command study 🚀

> 리눅스 환경 개발에 로켓을 달자! 📗 [ref](https://www.44bits.io/ko/post/linux-and-mac-command-line-survival-guide-for-beginner#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0)

<br />
<br />
<br />

## 1. 커널, 셸 그리고 터미널 프로그램이란?

### 커맨드라인 인터페이스

-   오로지 문자열로만 이루어진 인터페이스
-   구체적인 실체가 없는 추상적인 단어로 구성
-   이 환경에서는 문자열을 출력하거나 입력하는 것만 가능 **(only 문자열)**

### 터미널

-   커맨드라인 인터페이스가 물리적으로 구현된 기계
-   리눅스나 맥에서 제공되는 터미널 애플리케이션은 정확히는 가상 터미널 기계. 커맨드라인 인터페이스가 개념이라면, 터미널은 커맨드라인 인터페이스를 사용하는(혹은 구현하는) 물리적/가상적 기계라고 할 수 있음

### 셸

-   커맨드라인 인터페이스로 구현된 터미널에서 실행가능한 대화형 프로그램
-   즉, 커맨드라인 인터페이스로 운영체제 커널에 명령을 내릴 수 있는 인터렉티브 프로그램
-   셸은 REPL이라고도 부름. REPL이란 Read-eval-print-loop의 줄임말로 셸이 동작하는 방식에 대해서 잘 드러내줌.  
    🏷 먼저 사용자가 한 줄의 명령어(**텍스트**)를 입력하고 엔터를 누르면, 이 내용을 셸이 읽어들입니다.(**read**) 그리고 명령어를 해석해서 실행하고(**eval**), 실행된 결과를 출력(**print**)합니다. 셸은 이 과정을 반복(**loop**)합니다. 셸 위에서 사용자가 할 일은 "명령어"를 입력하는 것밖에 없습니다.

## 2. pwd : 현재 디렉터리는 어디인가?

터미널을 실행해서 `pwd`를 입력해봅니다.

```shell
$ pwd
/User/xtring
```

Shell을 실행하면 일반적으로 사용자 디렉터리에서 시작합니다. 맥의 경우 `/Users/<USER_NAME>`, 리눅스의 경우 `/home/<USER_NAME>`이 됩니다. 맥이나 리눅스에서는 디렉터리 구분자로 `/`를 사용합니다.

## 3. cd : 디렉터리 구조의 이해와 디렉터리 이동하기

디렉터리 구조는 최상위 루트 디렉터리(`/`)를 시작으로 디렉터리나 파일이 포함되어 있습니다. `/Users/xtring`는 루트 디렉터리(`/`)에 속한 `Users` 디렉터리에 속한 `xtring`디렉터리를 의미합니다.
디렉터리를 이동하기 위해서는 `cd` 명령어를 사용합니다. `cd` 명령어는 인자가 필요합니다. `cd <DIR>` 형식으로 명령어를 입력하면 `<DIR>` path 또는 디렉터리로 이동합니다.

```shell
$ cd /
$ pwd
/
```

위와 같이 명령어를 실행보면 디렉터리의 최상단(root)로 이동하고 경로를 확인해보니 잘 이동한 것을 볼 수 있습니다.

```shell
$ pwd
/
$ cd /Users/xtring
$ pwd
/Users/xtring
```

다시 원래 디렉터리로 이동해보았습니다.

4. 현재 디렉터리 표현법, 절대 경로와 상태 경로 이해하기
   Shell에서는 현재 디렉터리를 `.`(마침표)로 나타냅니다. 현재 디렉터리에서 현재 디렉터리로 이동해보겠니다.

```shell
$ pwd
/Users/xtring
$ cd .
$ pwd
/Users/xtring
```

/(루트 디렉터리)로 실행하는 경로명을 **절대 경로**라고 부릅니다. 절대 경로는 루트 리텍터리로부터 목적지까지 다다르는 모든 경로를 나타냅니다. `/Users/xtring`은 `/` 아래의 `Users` 아래의 `xtring` 디렉터리를 의미합니다. `.`은 이와 달리 상대 경로를 나타낼 때 주로 사용됩니다. 예를 들어 현재 디렉터리가 `/Users`라면 `/Users/xtring`의 **상태 경로**는 `./xtring`입니다.

일반적으로 `./`를 생략해도 상태경로를 의미합니다. 즉 `./xtring`과 `xtring`은 같은 의미를 가집니다. 하지만 절대 경로로 표현된 `/xtring`과는 완전히 다른 의미를 가집니다. 이 두가지 경로 지정 방법은 상황에 맞게 사용합니다.

(1) 내 위치를 정확히 아는 경우 >> 상대경로
(2) 내 위치를 정확히 모르는 경우 >> 절대 경로

## 5. 상위 디렉터리, 홈 디렉터리, 임시 디렉터리(/tmp)

`..`는 상위 디렉터리를 의미합니다.

```shell
$ pwd
/Users/xtring
$ cd ..
$ pwd
/Users
```

`..`을 여러번 사용하는 것도 가능합니다.

```shell
$ pwd
/Users/xtring
$ cd ../../
$ pwd
/
```

상대 디렉터리는 말 그대로 상대적인 개념이므로 논리적으로 확장 시킬 수도 있습니다.
이는 별 의미는 없지만 `../`를 통해 상대적으로 접근이 가능합니다.

```shell
$ pwd
/Users/xtring
$ cd ../xtring/../../Users/../Users/xtring
$ pwd
/Users/xtring
```

`~`는 홈디렉터리 입니다. 맥의 경우 홈 디렉터리는 `/Users/` 아래, 리눅스는 `/home/` 아래 입니다.
홈은 즉 사용자 계정의 위치를 말합니다. 제 경우 xtring이름을 가지고 있기 때문에 `/Users/xtring`이 되겠네요.

`~`를 확장한 표현법으로 `~<USERNAME>`이 있습니다. `~` 바로 뒤에 사용자 이름을 붙이면 사용자의 홈 디렉터리를 의미합니다. 앞서 `cd`를 사용하면 원하는 디렉토리로 이동하는 것을 알아보았는데 `cd` 뒤에 인자를 붙이지 않으면 홈 디렉터리로 바로 이동합니다.

사용자 권한으로 작업을 할 때는 일반적으로 홈 디렉터리를 사용합니다. 관리자 권한이 아닌 경우에는 루트 아래의 다른 디렉터리에 접근이 불가능한 경우도 있습니다. 임시로 자주 사용되는 디렉터리 중 하나가 `/tmp`이니 참고해주세요. 단, `/tmp`에 저장한 작업 내용은 재부팅하면 사라질 수 있으니 주의가 필요합니다.

추가적으로 사용자를 확인하는 명령어는 `whoami`입니다.

```shell
$ whoami
xtring
```

## 6. ls : 디렉터리의 정보 파악

셸에서 하는 가장 기본적인 작업은 디렉터리를 이동하고, 명령어를 실행하는 것입니다. 디렉터리에서 어떤 명령어를 실행하기 전 디렉터리의 정보를 얻는 것은 필수적이며 이를 알아보기 위해서 `ls` 명령어를 사용합니다.

`/etc` 디렉터리로 이동하고 `ls`를 실행해봅니다.
`/etc`는 주로 시스템과 관련된 설정 파일들이 모여있습니다. 그리고 파일, 폴더를 구분하지 않고 알파벳 순으로 나열합니다.

이 안에는 많은 디렉터리들과 파일이 있는 것을 확인할 수 있는데 기본적인 Bash 셸을 사용한다면 직관적으로 어떤 파일이 파일이고 디렉터리인지 확인할 수 없네요.

`-G` 옵션을 사용하면 타입에 따라서 다른 색으로 출력할 수 있습니다.

일반적으로 흰색으로 표시된 것은 파일, 색상이 있는 경우 디렉터리를 나타내지만 셸에 기능을 설정해 놓으셨다면 다른 색상으로 표시될 수 있습니다.

`ls -d */` 명령어를 사용하면 현재 디렉터리의 폴더들만 볼 수 있습니다.

`ls -l -G` 명령어를 사용하면 현재 디렉터리의 자세한 정보를 볼 수 있습니다. 여기서 `-l`은 long을 의미합니다. 자세한 정보는 권한, 소유자, 그룹, 파일크기, 수정일을 의미합니다.

기본적으로 `ls` 명령어는 알파벳순으로 파일과 폴터를 나열하지만 출력 순서를 정렬하는 방법도 있습니다.
`-t` 옵션은 최근에 수정된 파일 순서대로 정렬합니다.
`-S` 옵션은 사이즈가 큰 파일부터 출력해줍니다.
`-r` 옵션은 붙이면 순서를 거꾸로 출력해줍니다.
`-a` 옵션은 `.`으로 시작하는 모든 파일도 출력합니다.(`ls -al`: 디렉터리의 모든 파일, 폴더의 자세한 정보를 보기 위해서 자주 사용합니다.)

그렇다면 `ls -l -S -G -r`을 실행하면 어떻게 될까요?

현재 디렉터리의 파일 및 폴더의 자세한 정보를 보여주고 색깔로 파일과 폴더를 구분하며 작은 사이즈 크기 순으로 정렬합니다.

## 7. 파일, 디렉터리 조작을 위한 기본 명령어들

디렉터리 조작을 위한 기본 명령어들을 배우기 전 실습에 사용할 디렉터리를 생성하겠습니다.

```shell
$ cd ~
$ mkdir work
$ cd work
$ pwd
/Users/xtring/work
$ ls
```

여기서 `mkdir` 명령어는 현재 디렉터리에 인자로 받은 이름으로 디렉터리를 생성합니다. `mkdir <name>`
이렇게 디렉터리를 하나 생성했습니다. 그리고 마지막에 `ls`를 실행했지만 아무 내용이 나오지 않았습니다. 새로 생성한 디렉터리이니 당연한 것이죠.

아래 명령어는 가능할까요?

```shell
$ mkdir hello/world
```

아쉽지만 실패합니다. 아마 의도는 `hello` 디렉터리 아래에 `world` 디렉터리를 만들고 싶었을 거에요. 하지만 당연히 `hello` 디렉터리가 존재하지 않기 때문에 실패합니다...!

차례로 `hello` 디렉터리를 만들고, 다시 `cd`로 이동한 후 `world` 디렉터리를 만들 수도 있지만 원하는 데로 실행하지 못했네요. 이 경우 `-p` 옵션을 사용해서 한번에 디렉터리르 만들 수 있습니다.

```shell
$ mkdir -p hello/world
```

`ls`에 `-R` 옵션을 붙여 재귀적으로 현재 디렉터리 아래의 내용을 모두 확인해볼 수 있습니다.
(홈 디렉터리에서 사용하게되면 그 안의 모든 디렉터리를 순회함으로 hello 디렉터리로 이동해서 사용합니다.)

```shell
$ cd hello
$ ls -R
world

./world:
```

모든 폴더를 재귀적으로 순회하기 때문에 root에 가까운 곳에서 실행하게 되면 하루종일 실행되고 있을 수 있어요...!

이번에는 파일을 만들어보겠습니다. 파일을 만드는 가장 쉬운 방법은 `touch` 명령어를 사용하는 것입니다.
`touch <name>`

```shell
$ pwd
/Users/xtring/hello
$ touch a
$ ls -G
a     world
```

`touch`의 원래 용도는 (이미 존재하는) 파일의 접근 시간 혹은 수정 시간을 변경하는 일입니다. 그러나 이 처럼 빈 파일을 만드는 용도로도 많이 사용합니다. 여기서 만들어진 a 파일은 비어있습니다. `touch` 명령어를 통해서 여러 개 파일을 한꺼번에 만드는 것도 가능합니다.

```shell
$ touch b c d e
$ ls
a     b     c     d     e     world
```

`mv`는 파일 이름 이동, `cp`는 파일 복사에 사용합니다.

```shell
cp <SRC> <DEST>
mv <SRC> <DEST>
```

여기서 `<SRC>`는 복사/이동하고자 하는 파일의 경로, `<DEST>`는 새로운 경로입니다. `a` 파일을 `airport`로 이름을 변경하고, `b` 파일을 복사해 `batman`파일을 만들어보겠습니다.

```shell
$ mv a airport
$ ls
airport b   c   d   e   world
$ cp b batman
$ ls
airport b   batman  c   d   e   world
```

아래 명령어를 해석해봅시다.

```shell
$ mv airport world/
```

`world` 디렉터리 아래로 `airport`를 이동시킵니다. 라는 의미라는 것으로 해석되나요? 이 명령어는 `mv airport world/airport`와 같은 의미와 같습니다.

다시 파일을 상위 디렉터리로 옮길때는 절대 경로(/User/xtring/hello)를 지정할 수 도 있지만, 상대경로(../)를 사용하는 것이 더 간단합니다.

```shell
$ mv airport ../
$ cd ..
$ ls
airport b   batman  c   d   e   world
```

파일을 제거하기 위해서는 `rm` 명령어를 사용합니다. 디렉터리를 사용하는 명령어는 `rmdir`이 있지만 `rmdir`이 있지만 거의 사용하지 않고 `rm`에 옵션을 붙여 사용합니다. `rm <option> <name>`

```
$ rm -rf hello
```

`-rf` 명령어는 디렉터리와 그 아래의 모든 내용을 삭제할 수 있습니다. `rm` 명령어는 일반적인 삭제 방법과 다르게 바로 삭제됩니다. 이를 되돌릴 방법은 없으며 `rm -rf ~` 명령어를 실행하는 것은 매우 위험합니다. 기본적으로 관리자 권한에서 실행가능하지만 만에하나 시스템과 관련된 파일이 삭제되거나, 관리자 권한으로 실행되는 경우 대재앙을 맞이하게 될 것입니다.

## 8. 문자열 출력, 파일과 관련된 셸 기본 명령어 모음

문자열과 파일 내용을 출력하는 방법에 대해서 알아봅시다.

`echo`는 인자를 받아서 화면에 출력해줍니다.

```shell
$ echo Hello, world!
Hello, world!
```

`echo`를 독립적으로 쓸 일은 많지 않습니다. 커맨드라인에서 동작하는 프로그램을 작성할 때 화면에 문자열을 출력하는 기능으로 많이 사용됩니다.

`echo`는 셸 스크립트에서 사용하거나, 환경변수 출력에 사용할 수 있습니다.

```shell
$ echo My home directory is $HOME.
My home directory is /Users/xtring.
```

`$Home`이 `/Users/xtring`으로 치환된 것을 알 수 있습니다.

다음으로는 파일 내용을 출력하는 `cat`, `head`, `tail` 명령어에 대해서 알아보겠습니다. 가장 기본이 되는 명령어는 `cat`입니다.

`/etc`로 이동해서 `bashrc` 파일의 내용을 출력해봅시다.(또는 `bash.bashrc`)

```shell
$ cat bashrc
# System-wide .bashrc file for interactive bash(1) shells.
if [ -z "$PS1" ]; then
   return
fi

PS1='\h:\W \u\$ '
# Make bash check its window size after a process completes
shopt -s checkwinsize

[ -r "/etc/bashrc_$TERM_PROGRAM" ] && . "/etc/bashrc_$TERM_PROGRAM"
```

`cat`은 항상 파일의 전체 내용을 출력해줍니다. `head`는 파일의 앞부분 일부를 출력해주고, `tail`은 뒤에서 일부분을 출력해줍니다.
여기서 옵션을 추가해줄 수 있는데 `-n` 옵션을 사용하면 `<N>`을 인자로 받습니다. `head -n 2 bashrc`와 같이 사용하면 '앞부분의 두 줄을 출력하라.'의 의미와 같습니다.(`-n 2`와 `-n2`는 같습니다.)

반대로 `tail -n 2 bashrc`는 '마지막부분의 2줄을 출력하라.'라는 의미입니다.

```shell
$ head -n 2 bashrc
# System-wide .bashrc file for interactive bash(1) shells.
if [ -z "$PS1" ]; then

$ tail -n 2 bashrc

[ -r "/etc/bashrc_$TERM_PROGRAM" ] && . "/etc/bashrc_$TERM_PROGRAM"
```

`tail`은 `-f` 옵션과도 자주 사용됩니다. 예를 들어 서버 프로세스의 로그 파일의 경우, 서버에서 요청을 받을 때마다 로그 파일을 업데이트합니다. 이 때 `tail -f <FILE>`과 실행해두면, `tail` 프로그램이 종료되지 않고 업데이트되는 내용을 바로 출력해줍니다.
